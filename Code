Hereâ€™s a hackathon structure that takes participants from zero to full deployment:

ğŸš€ Containerization & DevOps Hackathon â€” 6 Challenges
Theme: â€œFrom Code to Cloudâ€ â€” Take a simple Java app and deploy it to Kubernetes the modern way.

Challenge 1 â€” â€œWhatâ€™s in the Box?â€ (Easy)
Topic: Understanding Docker & Writing a Dockerfile
Participants are given the raw Java app from Bitbucket (no Dockerfile). Their job is to understand what the app does, then write a Dockerfile from scratch that builds and runs it.
Hands-on tasks:
	âˆ™	Clone the repo from Bitbucket
	âˆ™	Write a multi-stage Dockerfile (build stage with Maven/Gradle, runtime stage with JRE)
	âˆ™	Build the image locally: docker build -t myapp:v1 .
	âˆ™	Run the container and hit the endpoint: docker run -p 8080:8080 myapp:v1
	âˆ™	Verify the app responds
Win condition: App runs in a container and returns a valid response on localhost.

Challenge 2 â€” â€œAutomate the Buildâ€ (Easy-Medium)
Topic: CI Pipeline with ACCP â€” Build & Tag the Image
Participants configure an ACCP CI pipeline that automatically builds the Docker image when code is pushed to Bitbucket.
Hands-on tasks:
	âˆ™	Connect Bitbucket repo to ACCP
	âˆ™	Write the pipeline definition file (.yml or equivalent) with stages: checkout â†’ build jar â†’ docker build â†’ tag image
	âˆ™	Use branch name or commit hash as the image tag
	âˆ™	Trigger the pipeline with a code push and watch it run
Win condition: Pipeline runs end-to-end and produces a tagged Docker image in ACCP artifacts.

Challenge 3 â€” â€œShip It to the Registryâ€ (Medium)
Topic: Push Image to JFrog Artifactory
Participants extend the CI pipeline to push the built image to JFrog.
Hands-on tasks:
	âˆ™	Configure JFrog credentials in ACCP as secrets/environment variables
	âˆ™	Add a docker push step to the pipeline pointing to the JFrog Docker registry
	âˆ™	Verify the image appears in JFrog with correct name and tag
	âˆ™	Pull the image back down locally to confirm it works: docker pull <jfrog-url>/myapp:v1
Win condition: Image is visible in JFrog Artifactory and pullable by other team members.

Challenge 4 â€” â€œPackage It with Helmâ€ (Medium)
Topic: Writing a Helm Chart for the Application
Participants create a Helm chart that defines how the Java app will run in Kubernetes â€” no hardcoded values, everything parameterized.
Hands-on tasks:
	âˆ™	Run helm create myapp and clean up the template boilerplate
	âˆ™	Define Deployment, Service, and ConfigMap templates
	âˆ™	Parameterize image name, tag, replica count, and port in values.yaml
	âˆ™	Lint the chart: helm lint ./myapp
	âˆ™	Do a dry-run against the Rancher cluster: helm install myapp ./myapp --dry-run --debug
Win condition: Helm dry-run produces valid Kubernetes manifests with no errors.

Challenge 5 â€” â€œDeploy with ArgoCDâ€ (Medium-Advanced)
Topic: GitOps Deployment to Kubernetes via ArgoCD
Participants push their Helm chart to a Git repo and wire it up to ArgoCD for automated deployment to Rancher.
Hands-on tasks:
	âˆ™	Push the Helm chart to a dedicated helm-charts Git repo
	âˆ™	Create an ArgoCD Application manifest pointing to that repo and the target Rancher namespace
	âˆ™	Apply it and watch ArgoCD sync: kubectl apply -f argocd-app.yaml
	âˆ™	Access ArgoCD UI and verify the app shows as Synced & Healthy
	âˆ™	Hit the deployed appâ€™s endpoint from inside the cluster
Win condition: App is running in Kubernetes, deployed through ArgoCD, and shows green in the UI.

Challenge 6 â€” â€œClose the Loopâ€ (Advanced)
Topic: Full End-to-End â€” Code Change Flows to Production
The ultimate challenge. Participants make a small code change and watch it flow from commit all the way to a running updated pod in Kubernetes automatically.
Hands-on tasks:
	âˆ™	Make a visible code change (e.g., change an API response message)
	âˆ™	Push to Bitbucket â€” ACCP pipeline triggers, builds new image, pushes to JFrog with new tag
	âˆ™	Update values.yaml image tag in the Helm repo (manual or scripted via pipeline)
	âˆ™	ArgoCD detects the change and auto-syncs
	âˆ™	Verify the new pod is running with kubectl get pods and the new response is live
Bonus: Automate the values.yaml tag update inside the ACCP pipeline so itâ€™s fully hands-free.
Win condition: Zero manual steps after the code push â€” new version is live in Kubernetes.

ğŸ—ºï¸ Visual Flow Across All Challenges

[Bitbucket Code] â†’ [ACCP CI Build] â†’ [JFrog Registry]
                                            â†“
                                     [Helm Chart Repo]
                                            â†“
                                       [ArgoCD Sync]
                                            â†“
                                  [Rancher / Kubernetes]


Tips for Running the Hackathon
Each challenge should have a starter kit (pre-cloned repo, credentials pre-configured) so teams arenâ€™t stuck on setup. Give each team a dedicated Kubernetes namespace in Rancher. Use a shared scoreboard where teams mark challenges complete after a mentor validates. Time-box each challenge to 45â€“60 minutes so the full day covers the entire pipeline.â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹
